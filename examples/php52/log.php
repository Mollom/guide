<?php

/**
 * @file
 * Logging helpers.  Ignore this file.
 */

/**
 * Log message severity -- Emergency: system is unusable.
 */
define('WATCHDOG_EMERGENCY', 0);

/**
 * Log message severity -- Alert: action must be taken immediately.
 */
define('WATCHDOG_ALERT', 1);

/**
 * Log message severity -- Critical conditions.
 */
define('WATCHDOG_CRITICAL', 2);

/**
 * Log message severity -- Error conditions.
 */
define('WATCHDOG_ERROR', 3);

/**
 * Log message severity -- Warning conditions.
 */
define('WATCHDOG_WARNING', 4);

/**
 * Log message severity -- Normal but significant conditions.
 */
define('WATCHDOG_NOTICE', 5);

/**
 * Log message severity -- Informational messages.
 */
define('WATCHDOG_INFO', 6);

/**
 * Log message severity -- Debug-level messages.
 */
define('WATCHDOG_DEBUG', 7);

/**
 * Adds a log entry to a global log (per-request).
 *
 * The Mollom client may perform multiple requests, and the client is able to
 * recover from certain errors. The details of each request are important for
 * support and debugging, but individual log messages for each request are too
 * much and would confuse users, especially when (false-)errors appear in
 * between.
 *
 * Therefore, the Mollom module collects all messages generated by the module
 * integration code as well as by the Mollom client class within a single
 * request, and only logs a single message when the request ends.
 *
 * This collection expects that at least one entry is logged that contains the
 * primary log message and its severity.
 *
 * @param array $entry
 *   (optional) An associative array describing the entry to add to the log.
 *   If supplied, the special keys 'message' and 'arguments' are taken over as
 *   primary log message. All other key/value pairs will be appended to the
 *   resulting log message, whereas the key denotes a label/heading and the
 *   value is var_export()ed afterwards, unless NULL.
 * @param int $severity
 *   (optional) The severity of the primary log message, as per RFC 3164.
 *   Possible values are WATCHDOG_ERROR, WATCHDOG_WARNING, etc. See watchdog()
 *   for details. Defaults to WATCHDOG_NOTICE when a 'message' is passed.
 * @param bool $reset
 *   (optional) Whether to empty the log and return its contents.
 *
 * @return array
 *   An associative array containing the log:
 *   - message: The primary log message.
 *   - arguments: An array of placeholder token replacement values for
 *     _mollom_format_string().
 *   - severity: The severity of the primary log message.
 *   - entries: A list of all $entry items that have been passed in.
 *
 * @see mollom_exit()
 */
function mollom_log(array $entry = NULL, $severity = NULL, $reset = FALSE) {
  // Start with debug severity level.
  static $log = array();

  if ($reset) {
    $return = $log;
    $log = array();
    return $return;
  }
  if (!isset($entry)) {
    return $log;
  }
  // Take over the primary message.
  // Only the module integration code sets a message.
  if (isset($entry['message'])) {
    $log['message'] = $entry['message'];
    $log['arguments'] = isset($entry['arguments']) ? $entry['arguments'] : array();

    // Default to notice severity for module messages.
    if (!isset($severity)) {
      $severity = WATCHDOG_NOTICE;
    }
  }

  if (!isset($log['severity'])) {
    $log['severity'] = WATCHDOG_DEBUG;
  }
  // Update severity, if the entry is more severe than existing.
  // Fail-over handling for requests is encapsulated in the Mollom class, which
  // only passes the final severity already.
  if (isset($severity) && $severity < $log['severity']) {
    $log['severity'] = $severity;
  }

  $log['entries'][] = $entry;

  return $log;
}

/**
 * Logs a single system message potentially containing multiple Mollom log entries.
 *
 * @see mollom_log()
 * @see _mollom_format_log()
 * @see watchdog()
 */
function mollom_log_write() {
  // Retrieve the log and reset it.
  $log = mollom_log(NULL, NULL, TRUE);
  if (empty($log)) {
    return;
  }
  list($message, $arguments) = _mollom_format_log($log);
  #watchdog('mollom', $message, $arguments, $log['severity']);
  return _mollom_format_string($message, $arguments);
}

/**
 * Log a Mollom system message.
 *
 * @param $log
 *   @todo A list of message parts. Each item is an associative array whose keys are
 *   log message strings and whose corresponding values are t()-style
 *   replacement token arguments. At least one part is required.
 */
function _mollom_format_log(array $log) {
  $message = isset($log['message']) ? $log['message'] : '';
  $arguments = isset($log['arguments']) ? $log['arguments'] : array();

  // Hide further message details in the log overview table, if any.
  // @see theme_dblog_message()
  if (!empty($log['entries'])) {
    // A <br> would be more appropriate, but filter_xss_admin() does not allow it.
    //$message = '<p>' . $message . '</p>' . "\n\n";
    $message = $message . "<p>\n\n</p>";
  }

  // Walk through each log entry to prepare and format its message and arguments.
  $i = 0;
  foreach ($log['entries'] as $entry) {
    // Take over message and arguments literally (if any).
    if (isset($entry['message'])) {
      $message .= '<p>';
      if (!empty($entry['arguments'])) {
        $message .= _mollom_format_string($entry['message'], $entry['arguments']);
        unset($entry['arguments']);
      }
      else {
        $message .= $entry['message'];
      }
      unset($entry['message']);
      $message .= "</p>\n";
    }
    unset($entry['severity']);

    // Prettify replacement token values, if possible.
    foreach ($entry as $token => $array) {
      // Only prettify non-scalar values plus Booleans.
      // I.e., NULL, TRUE, FALSE, array, and object.
      if (is_scalar($array) && !is_bool($array)) {
        $value = $array;
      }
      else {
        $flat_value = NULL;
        // Convert arrays and objects.
        // @todo Objects?
        if (isset($array) && !is_scalar($array)) {
          $ref = &$array;
          $key = key($ref);
          $parents = array();
          $flat_value = '';
          while ($key !== NULL) {
            if (is_scalar($ref[$key]) || is_bool($ref[$key]) || is_null($ref[$key])) {
              $value = var_export($ref[$key], TRUE);
              // Indent all values to have a visual separation from the last.
              $flat_value .= str_repeat('  ', count($parents) + 1) . "{$key} = {$value}\n";
            }

            // Recurse into nested keys, if the current key is not scalar.
            if (is_array($ref[$key])) {
              $flat_value .= str_repeat('  ', count($parents) + 1) . "{$key} =\n";
              $parents[] = &$ref;
              $ref = &$ref[$key];
              $key = key($ref);
            }
            else {
              // Move to next key if there is one.
              next($ref);
              if (key($ref) !== NULL) {
                $key = key($ref);
              }
              // Move back to parent key, if there is one.
              elseif ($parent = array_pop($parents)) {
                $ref = &$parent;
                next($ref);
                $key = key($ref);
              }
              // Otherwise, reached the end of array and recursion.
              else {
                $key = NULL;
              }
            }
          }
        }
        $value = NULL;
        // Use prettified string representation.
        if ($flat_value !== NULL) {
          $value = $flat_value;
        }
        // Use var_export() for Booleans.
        // Do not output NULL values on the top-level to allow for labels without
        // following value.
        elseif ($array !== NULL) {
          $value = var_export($array, TRUE);
        }
      }

      // Inject all other key/value pairs as @headingN (and optional
      // '<pre>@valueN</pre>') placeholders.
      if (isset($value)) {
        $message .= "@heading{$i}\n<pre>@value{$i}</pre>\n";
        $arguments += array(
          '@heading' . $i => $token,
          '@value' . $i => $value,
        );
      }
      else {
        $message .= "<p>@heading{$i}</p>\n";
        $arguments += array(
          '@heading' . $i => $token,
        );
      }
      $i++;
    }
  }
  return array($message, $arguments);
}

/**
 * Replaces placeholders with sanitized values in a string.
 *
 * Backported from Drupal 8.
 *
 * @param $string
 *   A string containing placeholders.
 * @param $args
 *   An associative array of replacements to make. Occurrences in $string of
 *   any key in $args are replaced with the corresponding value, after
 *   sanitization. The sanitization function depends on the first character of
 *   the key:
 *   - !variable: Inserted as is. Use this for text that has already been
 *     sanitized.
 *   - @variable: Escaped to HTML using check_plain(). Use this for anything
 *     displayed on a page on the site.
 *   - %variable: Escaped as a placeholder for user-submitted content using
 *     drupal_placeholder(), which shows up as <em>emphasized</em> text.
 *
 * @see t()
 * @ingroup sanitization
 */
function _mollom_format_string($string, array $args = array()) {
  // Transform arguments before inserting them.
  foreach ($args as $key => $value) {
    switch ($key[0]) {
      case '@':
        // Escaped only.
        $args[$key] = htmlspecialchars($value, ENT_QUOTES, 'UTF-8');
        break;

      case '%':
      default:
        // Escaped and placeholder.
        $args[$key] = '<em>' . htmlspecialchars($value, ENT_QUOTES, 'UTF-8') . '</em>';
        break;

      case '!':
        // Pass-through.
    }
  }
  return strtr($string, $args);
}

